# Multifractal patterns for natural (ecological) communities


## p-model

I use the following to have only one parameter:
$p2=p3=p4=(1-p1)/3$

The parameter *iter* (default=9) gives the image size $lado = 2^iter$
The parameter *rnd* is the how we assign p at each step S->random with reposition

```{r funcionesPmodel, echo=FALSE}

source('Fun_Multi_patt.r')
rm(list = ls())

setwd("p-model")
```


Simulate 10 times and store in sp, p1=0.3

```{r Simula_p1_03, echo=FALSE}
# Borro sp para guardar todo ahí
rm(sp,sa,compCI)

# 10 vueltas
p1 <- 0.3
fname='p03-9.sed'
for(i in 1:10)
{
  calc_pmodel1(fname,p1)
  #plot_pmodel1(fname,p1)
  sa <- calcDq_mfSBA(fname)
  sa$p1 <- p1
  sp <- if(!exists("sp")) sa else rbind(sp,sa)
}

png("Fig2_pmodel_p1_03.png", width=6,height=6,units="in",res=600)
plot_pmodel1(fname,p1)
dev.off()
compCI <- calcDq_bootCI(sp,p1,"boot")



```

Change p1=0.5, simulate again 10 times and store in sp

```{r Simula_p1_05, echo=FALSE}
p1 <- 0.5 
fname='p05-9.sed'
rm(sp)
for(i in 1:10)
{
  calc_pmodel1(fname,p1)
  plot_pmodel1(fname,p1)
  sa <- calcDq_mfSBA(fname)
  sa$p1 <- p1
  sp <- if(!exists("sp")) sa else rbind(sp,sa)
}

png("Fig3_pmodel_p1_05.png", width=6,height=6,units="in",res=600)
plot_pmodel1(fname,p1)
dev.off()

compCI <-rbind(compCI, calcDq_bootCI(sp,p1,"boot"))

```

Change p1=0.7 and simulate, the image have a few very high values, more spikyness 

```{r Simula_p1_07, echo=FALSE}

p1 <- 0.7 
fname='p07-9.sed'
rm(sp)
for(i in 1:10)
{
  calc_pmodel1(fname,p1)
  #plot_pmodel1(fname,p1)
  sa <- calcDq_mfSBA(fname)
  sa$p1 <- p1
  sp <- if(!exists("sp")) sa else rbind(sp,sa)
}
png("Fig4_pmodel_p1_07.png", width=6,height=6,units="in",res=600)
plot_pmodel1(fname,p1)
dev.off()

compCI <-rbind(compCI, calcDq_bootCI(sp,p1,"boot"))


```

Compare Dq for the different p1  

```{r Fig1_DqComp_p1, echo=FALSE}

trellis.par.set(superpose.symbol=list(cex=c(rep(0.6,11))))
sapply(compCI,class) 
compCI$Dq <- unlist(compCI$Dq)
compCI$HighCI <- unlist(compCI$HighCI)
compCI$LowCI <- unlist(compCI$LowCI)

png("Fig1_DqComp_p1.png", width=6,height=6,units="in",res=600)
with(compCI,
    xYplot(Cbind(Dq,LowCI,HighCI) ~ q, data=compCI, nx=FALSE, groups=p1, type="l",
           scales=list(tck=-1),
           cap=.01,
           ylim=c(min(LowCI)-.01,max(HighCI)+.01),
           panel=function(...){
           panel.abline(h=2, col="grey", lty=2)
  		     panel.xYplot(...)},
  		     ylab=expression(italic(D[q])),
  		     xlab=expression(italic(q)),
           label.curves=F,
           auto.key=list(x=.65,y=.9,title=expression(italic(p[1])),cex.title=.9, lines=T,points=F,cex=.7),
           )
       )
dev.off()


```

The previous generated figures are part of the paper's figure 1

Next I simulate for p=0.51

```{r Simula_p_051, echo=FALSE}
p1 <- 0.51 
fname='p051-9.sed'
rm(sp)
for(i in 1:10)
{
  calc_pmodel1(fname,p1)
  #plot_pmodel1(fname,p1)
  sa <- calcDq_mfSBA(fname)
  sa$p1 <- p1
  sp <- if(!exists("sp")) sa else rbind(sp,sa)
}
png("Fig3a_pmodel_p1_051.png", width=6,height=6,units="in",res=600)
plot_pmodel1(fname,p1)
dev.off()

# Calculate bootstraped CI
compCI <-rbind(compCI, calcDq_bootCI(sp,p1,"boot"))
```

Build graph to compare p-models p1=0.50 y 0.51

```{r Fig3b_DqComp_051, echo=FALSE}

trellis.par.set(superpose.symbol=list(cex=c(rep(0.6,11))))
sapply(compCI,class) 
compCI$Dq <- unlist(compCI$Dq)
compCI$HighCI <- unlist(compCI$HighCI)
compCI$LowCI <- unlist(compCI$LowCI)
compRE <- compCI[compCI$p1==0.5 | compCI$p1==0.51,]
require(Hmisc)
png("Fig3b_DqComp_051.png", width=6,height=6,units="in",res=600)
with(compRE,
    xYplot(Cbind(Dq,LowCI,HighCI) ~ q, data=compRE, nx=FALSE, groups=p1, type="l",
           scales=list(tck=-1),
           cap=.01,
           ylim=c(min(LowCI)-.01,max(HighCI)+.01),
           panel=function(...){
    	     panel.abline(h=2, col="grey", lty=2)
  		     panel.xYplot(...)},
  		     ylab=expression(italic(D[q])),
  		     xlab=expression(italic(q)),
           label.curves=F,
           auto.key=list(x=.65,y=.9,title=expression(italic(p[1])),cex.title=.9, lines=T,points=F,cex=.7),
           )
       )
dev.off()

```

Statistical comparison using compareGrowthCurves

```{r compare_p05vs51, echo=FALSE}
p1 <- 0.50 
fname='p05-9.sed'
for(i in 1:10)
{
  calc_pmodel1(fname,p1)
  #plot_pmodel1(fname,p1)
  sa <- calcDq_mfSBA(fname)
  sa$p1 <- p1
  sp <- if(!exists("sp")) sa else rbind(sp,sa)
}
sp <-na.omit(sp)
sp$rep <- rep( 1:20,each=20)
require(statmod)
require(reshape2)
compDq <- melt(sp, id.vars=c(1,4,5),measure.var="Dq")
names(compDq)
c1 <-dcast(compDq, p1+rep ~ q)
compareGrowthCurves(c1$p1,c1[,3:22],nsim=1000)
names(c1[,13:22])

compareGrowthCurves(c1$p1,c1[,13:22],nsim=1000)

names(c1[,3:12])

compareGrowthCurves(c1$p1,c1[,3:12],nsim=1000)

```
Global comparison is not significative

 Group1 Group2       Stat P.Value adj.P.Value
1    0.5   0.51 -0.1568175   0.683       0.683

If only compare positive q

  Group1 Group2  Stat P.Value adj.P.Value
1    0.5   0.51 2.255   0.021       0.021

Comparing only negative q 

  Group1 Group2      Stat P.Value adj.P.Value
1    0.5   0.51 -2.568635   0.016       0.016

The results are the same as boot CI

What happens with equal p1

```{r compare_p1_05vs05, echo=FALSE}


sp$p1a <- with(sp,as.character(p1))

p1 <- 0.50 
p1a <- "0.5a"
fname='p05-9.sed'
for(i in 1:10)
{
  calc_pmodel1(fname,p1)
  #plot_pmodel1(fname,p1)
  sa <- calcDq_mfSBA(fname)
  sa$p1 <- p1
  sa$p1a <- p1a
  sa$rep <- i
  sp <- if(!exists("sp")) sa else rbind(sp,sa)
}
sp <-na.omit(sp)

require(statmod)
require(reshape2)
compDq <- melt(sp, id.vars=c(1,5,6),measure.var="Dq")
names(compDq)
c1 <-dcast(compDq, p1a+rep ~ q)

compareGrowthCurves(c1$p1,c1[,3:22],nsim=1000)
names(c1[,13:22])
compareGrowthCurves(c1$p1,c1[,13:22],nsim=1000)

names(c1[,3:12])

compareGrowthCurves(c1$p1,c1[,3:12],nsim=1000)

```

For q>0
  Group1 Group2       Stat P.Value adj.P.Value
1    0.5   0.51  2.2550003   0.027       0.054
2    0.5   0.5a -0.7126422   0.468       0.468
3   0.51   0.5a -2.6325264   0.010       0.030

For q<0
Group1 Group2      Stat P.Value adj.P.Value
1    0.5   0.51 -2.568635   0.010       0.020
2    0.5   0.5b  1.923710   0.068       0.068
3   0.51   0.5b  3.640657   0.002       0.006

When p1 are equal there is no significative diferences 


```{r compare_p03vs031, echo=FALSE}

p1 <- 0.30
fname='p03-9.sed' 
sa <-repeat_pmodel(p1,fname,10)
sp <-if(!exists("sp")) sa else rbind(sp,sa)

p1 <- 0.31 
fname='p03-9.sed' 
sa <-repeat_pmodel(p1,fname,10)
sp <-rbind(sp,sa)

# generate another set with p1=0.3
p1 <- 0.30
fname='p03-9.sed' 
sa <-repeat_pmodel(p1,fname,10)
sa$p1 <- 0.301
sp <-rbind(sp,sa)

sp$rep <- rep( 1:10,times=3,each=20)
require(statmod)
require(reshape2)
compDq <- melt(sp, id.vars=c(1,5,6),measure.var="Dq")
names(compDq)
c1 <-dcast(compDq, p1+rep ~ q)
#compareGrowthCurves(c1$p1,c1[,3:22],nsim=1000)
names(c1[,13:22])
# q>0
compareGrowthCurves(c1$p1,c1[,13:22],nsim=1000)

names(c1[,3:12])
# q<0
compareGrowthCurves(c1$p1,c1[,3:12],nsim=1000)

compCI <-rbind(compCI, calcDq_bootCI(sa,p1,"boot"))


trellis.par.set(superpose.symbol=list(cex=c(rep(0.6,11))))
sapply(compCI,class) 
compCI$Dq <- unlist(compCI$Dq)
compCI$HighCI <- unlist(compCI$HighCI)
compCI$LowCI <- unlist(compCI$LowCI)
compRE <- compCI[(compCI$p1==0.3 | compCI$p1==0.31) & compCI$Type=="boot",]
require(Hmisc)
# png("Fig3c_DqComp_031", width=6,height=6,units="in",res=600)
with(compRE,
    xYplot(Cbind(Dq,LowCI,HighCI) ~ q, data=compRE, nx=FALSE, groups=p1, type="l",
           scales=list(tck=-1),
           cap=.01,
           ylim=c(min(LowCI)-.01,max(HighCI)+.01),
           panel=function(...){
           panel.abline(h=2, col="grey", lty=2)
  		     panel.xYplot(...)},
  		     ylab=expression(italic(D[q])),
  		     xlab=expression(italic(q)),
           label.curves=F,
           auto.key=list(x=.65,y=.9,title=expression(italic(p[1])),cex.title=.9, lines=T,points=F,cex=.7),
           )
       )
#dev.off()


#sa <- sp[sp$p1==.3,] 
#compCI <-compCI[!(compCI$p1==0.3 & compCI$Type=="boot"),] 
#p1<-0.3
#compCI <-rbind(compCI, calcDq_bootCI(sa,p1,"boot"))

rm(sp,sa,compRE,compDq,c1)
```
p1=0.3 vs 0.31
for positive q 
  Group1 Group2       Stat P.Value adj.P.Value
1    0.3  0.301  0.8103345   0.423       0.423
2    0.3   0.31 13.3516719   0.000       0.000
3  0.301   0.31 12.8468636   0.000       0.000

Para q negativo
  Group1 Group2        Stat P.Value adj.P.Value
1    0.3  0.301  -0.5430853   0.578       0.578
2    0.3   0.31 -15.7349328   0.000       0.000
3  0.301   0.31 -14.8506549   0.000       0.000

```{r compare_p07vs071, echo=FALSE}
p1 <- 0.70
fname='p07-9.sed' 
sa <-repeat_pmodel(p1,fname,10)
sp <-if(!exists("sp")) sa else rbind(sp,sa)

p1 <- 0.71 
fname='p07-9.sed' 
sa <-repeat_pmodel(p1,fname,10)
sp <-rbind(sp,sa)

# generate another set with p1=0.7
p1 <- 0.70
fname='p03-9.sed' 
sa <-repeat_pmodel(p1,fname,10)
sa$p1 <- 0.701
sp <-rbind(sp,sa)

sp$rep <- rep( 1:10,times=3,each=20)

require(statmod)
require(reshape2)
compDq <- melt(sp, id.vars=c(1,5,6),measure.var="Dq")
names(compDq)
c1 <-dcast(compDq, p1+rep ~ q)
#compareGrowthCurves(c1$p1,c1[,3:22],nsim=1000)
names(c1[,13:22])

compareGrowthCurves(c1$p1,c1[,13:22],nsim=1000)

names(c1[,3:12])

compareGrowthCurves(c1$p1,c1[,3:12],nsim=1000)

# compCI <-rbind(compCI, calcDq_bootCI(sa,p1,"boot"))

trellis.par.set(superpose.symbol=list(cex=c(rep(0.6,11))))
sapply(compCI,class) 
compCI$Dq <- unlist(compCI$Dq)
compCI$HighCI <- unlist(compCI$HighCI)
compCI$LowCI <- unlist(compCI$LowCI)
compRE <- compCI[(compCI$p1==0.7 | compCI$p1==0.71) & compCI$Type=="boot",]
require(Hmisc)
#png("Fig3d_DqComp_071", width=6,height=6,units="in",res=600)
with(compRE,
    xYplot(Cbind(Dq,LowCI,HighCI) ~ q, data=compRE, nx=FALSE, groups=p1, type="l",
           scales=list(tck=-1),
           cap=.01,
           ylim=c(min(LowCI)-.01,max(HighCI)+.01),
           panel=function(...){
           panel.abline(h=2, col="grey", lty=2)
    	     panel.xYplot(...)},
  		     ylab=expression(italic(D[q])),
  		     xlab=expression(italic(q)),
           label.curves=F,
           auto.key=list(x=.65,y=.9,title=expression(italic(p[1])),cex.title=.9, lines=T,points=F,cex=.7),
           )
       )
#dev.off()


#sa <- sp[sp$p1==.7,] 
#compCI <-compCI[!(compCI$p1==0.7 & compCI$Type=="boot"),] 
#p1<-0.7
#compCI <-rbind(compCI, calcDq_bootCI(sa,p1,"boot"))

rm(sp,sa,compRE,compDq,c1)


```

Comparing p1=0.7 vs 0.71
q>0
Group1 Group2       Stat P.Value adj.P.Value
1    0.7  0.701 -0.8075292   0.390       0.780
2    0.7   0.71  0.4495824   0.649       0.780
3  0.701   0.71  1.2609164   0.217       0.651
q<0
  Group1 Group2       Stat P.Value adj.P.Value
1    0.7  0.701 -0.1335561   0.898       0.898
2    0.7   0.71 -3.4012475   0.002       0.006
3  0.701   0.71 -3.2216229   0.005       0.010

Ahora comparo SD de bootstrap con sd de regresiones

```{r SDboot_vs_SDRegr_p1_05, echo=FALSE}

# Los datos de las simulaciones estan en sp
# y guarde los resultados en compCI

qci<- with(sp, sapply(SD.Dq,calcCI,8,0.05))
sp$LowCI <- sp$Dq-qci
sp$HighCI <- sp$Dq+qci
require(plyr)
qci <- ddply(sp,.(q,p1), colMeans)
qci$Type <- "regr"
qci <- qci[,c(1:4,6:8)]

compCI <- rbind(compCI,qci)
rm(qci)


```

Los valores del ci por boot siempre son mayores para q>0 y menores para q<0 

Que pasa si calculo para p1=0.3 (está en sp)

```{r SDboot_vs_SDRegr_p1_03, echo=FALSE}

qci<- with(sp, sapply(SD.Dq,calcCI,8,0.05))
sp$LowCI <- sp$Dq-qci
sp$HighCI <- sp$Dq+qci
require(plyr)
qci <- ddply(sp,.(q,p1), colMeans)
qci$Type <- "regr"
qci<-na.omit(qci)
names(qci)
compCI <- rbind(compCI,qci)

rm(qci)

# uso SD*2 
qci<- with(sp, SD.Dq*2)
sp$LowCI <- sp$Dq-qci
sp$HighCI <- sp$Dq+qci
require(plyr)
qci <- ddply(sp,.(q,p1), colMeans)
qci$Type <- "regr2"
qci<-na.omit(qci)
compCI <- rbind(compCI,qci)

compRE <- compCI[compCI$p1==0.3,]
require(lattice)
#png("Fig5_CI_bootRegr_p1_03.png", width=6,height=6,units="in",res=600)
barchart((HighCI-LowCI) ~ factor(q), data=compRE, groups=Type,ylab="CI",
         auto.key = list(x=.60,y=.9,points = FALSE, rectangles = T))
#dev.off()

```

```{r SDboot_vs_SDRegr_p1_07, echo=FALSE}

# have to be loaded in sp with p1=0.7
#
qci<- with(sp, sapply(SD.Dq,calcCI,8,0.05))
sp$LowCI <- sp$Dq-qci
sp$HighCI <- sp$Dq+qci
require(plyr)
qci <- ddply(sp,.(q,p1), colMeans)
qci$Type <- "regr"
qci<-na.omit(qci)
names(qci)
names(compCI)
qci <- qci[, names(compCI)]
compCI <- rbind(compCI,qci)

rm(qci)

```

```{r D1_DeltaDq, echo=FALSE}

#Calculate D1 and DeltaDq(-5,5)
require(plyr)

d1_delta <- ddply(compCI, .(p1,Type),summarize, 
                  DeltaDq = Dq[q==-5]-Dq[q==5], 
                  SD.DeltaDq=sqrt(SD.Dq[q==-5]^2+SD.Dq[q==5]^2),
                  D1=Dq[q==1],
                  SD.D1=SD.Dq[q==1]   )

# A pandoc table could be generated with pander

require(pander)
options(scipen=3,digits=5)
panderOptions('table.style','grid')
pander(d1_delta)

setwd("..")
```

The frame compCI have all the results. 

Comparing CI, the one calculated from the regression and SD*2 are are generally lower than the bootstrap CI but not allways.

A possible solution would be to fit pmodel and calculate the CI with bootstrap.  Using SD*2 is not safe because some times is greater and we will think that they are equal when they are different (Type II error). 
